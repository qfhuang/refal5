$EXTERNAL Lex;

$ENTRY Parse
{
    'D' e.InVar ':' e.InExpr,
    <Variable   <Lex e.InVar>>  : t.OutVar,
    <Expression <Lex e.InExpr>> : t.OutExpr =
        (t.OutVar) t.OutExpr;

    e.X =;
}

AllFuncNamesSet
{
    = <FuncNamesSet> Plus Minus Mul Div Invol
}

FuncNamesSet
{
    = sin cos ln exp sqrt arcsin arccos;
}

IsMacrodigit
{
    s.1, <Type s.1> : 'N0' s.1 = True;

    s.1 = False;
}

IsVariable
{
    s.1, <Type s.1> : 'Wi' s.1,
    <Contain (<AllFuncNamesSet>) s.1> : False = True;

    s.1 = False;
}

/* TODO: recursive processing expression e.g. "---5", necessary? */
SNumber
{
    s.Macrodigit,
    <IsMacrodigit s.Macrodigit> : True =
        s.Macrodigit;

    Plus s.Macrodigit,
    <IsMacrodigit s.Macrodigit> : True =
        s.Macrodigit;

    Minus s.Macrodigit,
    <IsMacrodigit s.Macrodigit> : True =
        (MonadicMinus s.Macrodigit);

    e.X =;
}

Number
{
    s.Macrodigit,
    <IsMacrodigit s.Macrodigit> : True =
        s.Macrodigit;

    e.X =;
}

Variable
{
    s.Variable,
    <IsVariable s.Variable> : True =
        s.Variable;

    e.X =;
}

Invol
{
    e.InExpr Invol e.InSNumber,
    <Expression e.InExpr> : t.OutExpr,
    <SNumber e.InSNumber> : t.OutSNumber =
        (Invol t.OutExpr t.OutSNumber);

    e.X =;
}

Expr_0
{
    t.Macrodigit,
    <IsMacrodigit t.Macrodigit> : True =
        t.Macrodigit;

    t.Variable,
    <IsVariable t.Variable> : True =
        t.Variable;

    e.InInvol,
    <Invol e.InInvol> : t.OutInvol =
        t.OutInvol;

    t.FuncName '(' e.InExpr ')',
    <Contain (<FuncNamesSet>) t.FuncName> : True,
    <Expression e.InExpr> : t.OutExpr =
        (t.FuncName t.OutExpr);

    '(' e.Expr ')',
    <Contain ('(' ')') e.Expr> : False,
    <Expression e.Expr> : t.OutExpr =
        t.OutExpr;

    e.X =;
}

Expr_1
{ 
    Plus e.InExpr_1,
    <Expr_1 e.InExpr_1> : t.OutExpr_1 =
        t.OutExpr_1;

    Minus e.InExpr_1,
    <Expr_1 e.InExpr_1> : t.OutExpr_1 =
        (MonadicMinus t.OutExpr_1);

    e.InExpr_0,
    <Expr_0 e.InExpr_0> : t.OutExpr_0 =
        t.OutExpr_0;

    e.X =;
}

Expr_2
{
    e.InExpr_1 s.Op e.InExpr_2,
    <Contain (Mul Div) s.Op> : True,
    <Expr_1 e.InExpr_1> : t.OutExpr_1,
    <Expr_2 e.InExpr_2> : t.OutExpr_2 =
        (s.Op t.OutExpr_1 t.OutExpr_2);

    e.InExpr_1,
    <Expr_1 e.InExpr_1> : t.OutExpr_1 =
        t.OutExpr_1;

    e.X =;
}

Expression
{
    /* TODO: e.InExpr s.Op e.InExpr_2 */
    e.InExpr_2 s.Op e.InExpr,
    <Contain (Plus Minus) s.Op> : True,
    <Expr_2     e.InExpr_2> : t.OutExpr_2,
    <Expression e.InExpr>   : t.OutExpr =
        (s.Op t.OutExpr_2 t.OutExpr);

    e.InExpr_2,
    <Expr_2 e.InExpr_2> : t.OutExpr_2 =
        t.OutExpr_2;

    e.X =;
}

/*
* <InSet (Set) Symbol>.
InSet
{
    (e.X s.2 e.Y) s.2 = True;
    (e.1) s.2         = False;
}

* <Contain (Set) Symbols>.
Contain
{
    () e.2 = False;
    (e.1)  = False;

    (e.1) e.2 s.3 e.4, <Contain (e.1) s.3> : True = True;

    (e.1) e.2 = False;
}
*/

* <Contain (Set) Symbols>.
Contain
{
    (e.1 s.X e.2) e.3 s.X e.4 = True;
    (e.1) e.2                 = False;
}

/*
ParseParentheses
{
    e.1 '(' e.2 ')' e.3, <ContainParentheses e.2> : False =
        <Parse e.1 (e.2) e.3>;

    e.1 '(' e.2 =
        <Prout 'Parse: unpaired left parentheses: '  e.1 '(' e.2>;

    e.1 ')' e.2 =
        <Prout 'Parse: unpaired right parentheses: ' e.1 ')' e.2>;

    e.1 = e.1;
}

ContainParentheses
{
    e.1 '(' e.2 = True;
    e.1 ')' e.2 = True;
    e.1         = False;
}
*/
