$EXTERNAL Lex;
$EXTERNAL FuncNamesSet;
$EXTERNAL Contain;
$EXTERNAL IsVariable;
$EXTERNAL IsMacrodigit;

$ENTRY Parse
{
    'D' e.InVar ':' e.InExpr,
    <Variable   <Lex e.InVar>>  : t.OutVar,
    <Expression <Lex e.InExpr>> : t.OutExpr =
        (t.OutVar) t.OutExpr;

    e.X =;
}

/* TODO: recursive processing expression e.g. "---5", necessary? */
SNumber
{
    s.Macrodigit,
    <IsMacrodigit s.Macrodigit> : True =
        s.Macrodigit;

    Plus s.Macrodigit,
    <IsMacrodigit s.Macrodigit> : True =
        s.Macrodigit;

    Minus s.Macrodigit,
    <IsMacrodigit s.Macrodigit> : True =
        (MonadicMinus s.Macrodigit);

    e.X =;
}

Number
{
    s.Macrodigit,
    <IsMacrodigit s.Macrodigit> : True =
        s.Macrodigit;

    e.X =;
}

Variable
{
    s.Variable,
    <IsVariable s.Variable> : True =
        s.Variable;

    e.X =;
}

Invol
{
    e.InExpr Invol e.InSNumber,
    <Expression e.InExpr> : t.OutExpr,
    <SNumber e.InSNumber> : t.OutSNumber =
        (Invol t.OutExpr t.OutSNumber);

    e.X =;
}

Function
{
    t.FuncName '(' e.InExpr ')',
    <Contain (<FuncNamesSet>) t.FuncName> : True,
    <Expression e.InExpr> : t.OutExpr =
        (t.FuncName t.OutExpr);

    e.X =;
}

Expr_0
{
    t.Macrodigit,
    <Number t.Macrodigit> : t.OutNumber =
        t.OutNumber;

    t.Variable,
    <IsVariable t.Variable> : True =
        t.Variable;

    e.InInvol,
    <Invol e.InInvol> : t.OutInvol =
        t.OutInvol;

    e.InFunction,
    <Function e.InFunction> : t.OutFunction =
        t.OutFunction;

    '(' e.Expr ')',
    <Expression e.Expr> : t.OutExpr =
        t.OutExpr;

    e.X =;
}

Expr_1
{ 
    Plus e.InExpr_1,
    <Expr_1 e.InExpr_1> : t.OutExpr_1 =
        t.OutExpr_1;

    Minus e.InExpr_1,
    <Expr_1 e.InExpr_1> : t.OutExpr_1 =
        (MonadicMinus t.OutExpr_1);

    e.InExpr_0,
    <Expr_0 e.InExpr_0> : t.OutExpr_0 =
        t.OutExpr_0;

    e.X =;
}

Expr_2
{
    e.InExpr_2 s.Op e.InExpr_1,
    <Contain (Mul Div) s.Op> : True,
    <Contain (Mul Div) e.InExpr_1> : False,
    <Expr_2 e.InExpr_2> : t.OutExpr_2,
    <Expr_1 e.InExpr_1> : t.OutExpr_1 =
        (s.Op t.OutExpr_2 t.OutExpr_1);

    e.InExpr_1,
    <Expr_1 e.InExpr_1> : t.OutExpr_1 =
        t.OutExpr_1;

    e.X =;
}

Expression
{
    e.InExpr s.Op e.InExpr_2,
    <Contain (Plus Minus) s.Op> : True,
    <Contain (Plus Minus) e.InExpr_2> : False,
    <Expression e.InExpr>   : t.OutExpr,
    <Expr_2     e.InExpr_2> : t.OutExpr_2 =
        (s.Op t.OutExpr t.OutExpr_2);

    e.InExpr_2,
    <Expr_2 e.InExpr_2> : t.OutExpr_2 =
        t.OutExpr_2;

    e.X =;
}
